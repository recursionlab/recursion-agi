---
nexus: nexus-ai-chat-importer
plugin_version: "1.3.0"
provider: claude
artifact_id: prompt_arsenal
version_uuid: eee1a1fa-7531-4f78-8aba-255cdaa5aa27
version_number: 1
command: create
conversation_id: 82d4e34c-c214-4c73-b09c-cdc05846e4ae
create_time: 2025-08-26T22:37:43.000Z
format: markdown
aliases: [Prompt Arsenal for Recursive Knowledge Base Construction, prompt_arsenal_v1]
---

# Prompt Arsenal for Recursive Knowledge Base Construction (Version 1)

**Conversation:** [[Nexus/Conversations/claude/2025/08/Recursive Singularity Planning|Recursive Singularity Planning]]

## Content

# Prompt Arsenal for Recursive Knowledge Base Construction

## ðŸ” **Proof-Reading & Refinement Prompt**
```
Analyze this content for:
- Logical consistency and flow
- Recursive contradictions or circular definitions  
- Meta-structural coherence (does the structure match the content?)
- Semantic density optimization (eliminate redundancy while preserving meaning)
- Identify any claims that need evidence or citations
- Flag areas where abstraction level shifts unexpectedly
- Check for proper use of technical terminology vs. accessible language
```

## ðŸ•¸ï¸ **Relational Connection Building Prompt**
```
Map the conceptual relationships in this content:
- Direct logical dependencies (A requires B to be understood)
- Analogical connections (A is structurally similar to B)
- Contradictory tensions (A and B create productive friction)
- Meta-level relationships (A is about the same type of thing as B)
- Recursive self-references (where does A reference itself?)
- Boundary conditions (where does A become not-A?)
- Emergent properties (what arises from A + B that neither has alone?)

Generate specific Obsidian links: [[concept]] and suggest new notes to create.
```

## ðŸ’Ž **Insight & Aphorism Harvesting Prompt**
```
Extract from this content:
- Distilled principles (core truths compressed to minimal form)
- Paradoxical tensions that generate insight
- Recursive patterns that appear at multiple scales
- Meta-cognitive observations (thoughts about thinking)
- Operational heuristics (rules of thumb for action)
- Boundary definitions (what distinguishes X from not-X)
- Phase transition points (where quantitative becomes qualitative)

Format as: "Insight: [concise statement] | Context: [where it applies] | Recursion: [how it loops back on itself]"
```

## ðŸ§® **Mathematical Logic Processing Prompt**
```
Analyze the mathematical/logical structure:
- Identify formal operators and their semantic meaning
- Map recursive relationships (f(f(x)) patterns)
- Extract logical dependencies and proof structures
- Identify fixed points and attractors
- Note any topological or categorical patterns
- Check for consistency of symbolic notation
- Suggest mathematical representations for conceptual relationships
- Identify where intuitive understanding diverges from formal representation

Convert abstract concepts into operational mathematical expressions where possible.
```

## âš¡ **Contradiction Mining & Processing Prompt**
```
Systematically extract contradictions:
- Direct logical contradictions (A and not-A)
- Pragmatic contradictions (action contradicts stated principle)
- Level-crossing contradictions (meta-level contradicts object-level)
- Temporal contradictions (past view contradicts present view)
- Recursive contradictions (self-reference creates paradox)

For each contradiction:
1. Is it resolvable or productively irresolvable?
2. What does it reveal about system boundaries?
3. Does it suggest a meta-level solution?
4. Can it be preserved as generative tension?

Tag with: #contradiction/[type] and #tension/[productive|destructive]
```

## ðŸ› ï¸ **Prompt Engineering Meta-Prompt**
```
Design a specialized prompt for: [TARGET TASK]

Consider:
- What cognitive operations need to be triggered?
- What level of abstraction is optimal?
- What examples or constraints guide performance?
- How should output be structured for downstream use?
- What meta-cognitive checks should be built in?
- How does this prompt recursively improve itself?
- What failure modes should be prevented?

Generate 3 variations: Basic, Advanced, and Recursive-Meta versions.
Test prompt against edge cases and refine.
```

## ðŸ”„ **Meta-Audit Feedback Loop Prompt**
```
Audit this content/system/process:
- Does it achieve its stated purpose?
- What are its hidden assumptions?
- How does it perform under stress/edge cases?
- What are its failure modes?
- How does it scale (up and down)?
- What does it optimize for vs. what it should optimize for?
- How does the audit process itself need auditing?
- What meta-level changes would improve performance?

Generate specific improvement actions with success criteria.
Create meta-audit criteria for evaluating this audit.
```

## ðŸŒ€ **Self-Reflexive Entropy Folding Prompt**
```
Analyze the entropy dynamics:
- Where does this system/idea generate new complexity?
- Where does it collapse complexity into simplicity?
- What information is lost/preserved in each compression?
- How does the system observe/modify itself?
- What happens when the system models its own modeling?
- Where do recursive loops amplify vs. stabilize?
- What entropy is necessary vs. parasitic?

Map the energy flows: creation â†’ organization â†’ maintenance â†’ decay â†’ regeneration
Identify points where entropy becomes productive vs. destructive.
```

## ðŸ—ï¸ **Systems & Framework Construction Prompt**
```
Build a systematic framework for: [DOMAIN]

Required components:
- Core principles (3-7 fundamental axioms)
- Operational procedures (how to use the system)
- Boundary conditions (where it applies/doesn't apply)
- Measurement criteria (how to evaluate success)
- Error correction mechanisms (how it self-improves)
- Scaling properties (how it handles complexity increases)
- Interface specifications (how it connects to other systems)

Design for:
- Robustness (works under varied conditions)
- Recursivity (system can operate on itself)
- Modularity (components can be recombined)
- Emergence (whole > sum of parts)
```

## ðŸ”‘ **Keyword & Pattern Extraction Prompt**
```
Extract semantic structure:
- Core concepts (nouns that carry most meaning)
- Operative processes (verbs that drive transformation)
- Qualifying relationships (prepositions and modifiers that specify connections)
- Recursive markers (self-reference indicators)
- Meta-level terms (words about words/concepts about concepts)
- Boundary terms (definitions and exclusions)
- Scale indicators (micro/macro/meta prefixes)

Generate:
- Tag hierarchy: #domain/subdomain/concept
- Relationship types: causes, enables, contradicts, generalizes
- Abstraction levels: concrete â†’ abstract â†’ meta-abstract
```

## ðŸŽ† **Creative Divergence & Brainstorming Prompt**
```
Generate creative variations on: [CONCEPT]

Divergence strategies:
- Analogical thinking: What else works like this?
- Inversion: What if we did the opposite?
- Scale shifting: What if this were 10x bigger/smaller?
- Temporal shifting: What if this occurred faster/slower/backwards?
- Dimensional shifting: What if this occurred in different domains?
- Recursive application: What if this process operated on itself?
- Constraint removal: What if [assumed limitation] didn't exist?
- Boundary dissolution: What if [category boundaries] were fluid?

For each variation:
- What new possibilities emerge?
- What problems does it solve/create?
- How does it interact with existing systems?
```

## ðŸ§¬ **Meta-Varieties of Prompt Categories**

### Recursive Meta-Prompts:
- **Self-Modifying Prompt Prompt**: Design prompts that rewrite themselves based on their own output
- **Prompt Ecology Prompt**: Create networks of prompts that feed into each other
- **Meta-Meta Prompt**: Design prompts for designing prompts for designing prompts

### Temporal Meta-Prompts:
- **Historical Analysis Prompt**: Trace conceptual evolution over time
- **Future Projection Prompt**: Extrapolate current patterns into future scenarios
- **Temporal Recursion Prompt**: Identify patterns that repeat across time scales

### Dimensional Meta-Prompts:
- **Cross-Domain Translation Prompt**: Transfer insights between unrelated fields
- **Abstraction Ladder Prompt**: Move concepts up/down levels of abstraction
- **Boundary Dissolution Prompt**: Explore what happens when category boundaries become fluid

### Cognitive Meta-Prompts:
- **Metacognitive Reflection Prompt**: Think about thinking processes
- **Cognitive Bias Detection Prompt**: Identify systematic thinking errors
- **Perspective Multiplication Prompt**: Generate multiple valid viewpoints on same phenomenon

### System Meta-Prompts:
- **Emergence Detection Prompt**: Identify where higher-order properties arise
- **System Boundary Prompt**: Define what's inside/outside system scope
- **Network Effect Prompt**: Analyze how components interact to create system behavior

---

## **CodeScript Plugin Integration Strategy**

The CodeScript plugin allows AI systems like me to execute code directly within Obsidian notes. Here's how we could leverage this:

### **Dynamic Template Generation**
```javascript
// CodeScript that generates custom templates based on content analysis
const contentAnalysis = await analyzeNoteContent(currentNote);
const templateType = determineOptimalTemplate(contentAnalysis);
await generateCustomTemplate(templateType, contentAnalysis.metadata);
```

### **Automated Relationship Mapping**
```javascript
// Generate Smart Connections between notes programmatically
const currentConcepts = extractConcepts(activeNote);
const relatedNotes = await findSemanticMatches(currentConcepts);
await createBidirectionalLinks(activeNote, relatedNotes);
```

### **Live Contradiction Detection**
```javascript
// Real-time contradiction analysis as you write
const contradictions = await scanForContradictions(noteContent);
contradictions.forEach(contradiction => {
    addInlineComment(contradiction.location, contradiction.analysis);
});
```

### **Recursive Meta-Processing**
```javascript
// Apply prompts recursively to their own outputs
let currentContent = getSelectedText();
for(let depth = 0; depth < 3; depth++) {
    currentContent = await applyPrompt(metaAnalysisPrompt, currentContent);
    appendToNote(`## Recursion Level ${depth + 1}\n${currentContent}\n`);
}
```

## Usage Instructions

1. **Template Structure**: Each prompt follows: Context Setup â†’ Specific Operations â†’ Output Format â†’ Meta-Checks
2. **Recursive Application**: Most prompts can be applied to their own outputs
3. **Combination Strategy**: Use 2-3 prompts in sequence for comprehensive analysis
4. **Feedback Integration**: Each prompt output should seed the next iteration
5. **Meta-Monitoring**: Track which prompt combinations produce highest-value insights

## Obsidian Integration

- Tag all outputs with prompt type: #prompt/[category]
- Link related analyses: [[Concept A]] â†’ [[Concept B Analysis]]
- Create template notes for frequently used prompt combinations
- Use dataview queries to track prompt effectiveness over time